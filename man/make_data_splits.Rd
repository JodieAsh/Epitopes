% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_data_splits.R
\name{make_data_splits}
\alias{make_data_splits}
\title{Split epitope data.}
\usage{
make_data_splits(
  peptides.list,
  proteins,
  split_level = "protein",
  target_props = c(0.75, 0.25),
  split_names = NULL,
  similarity_threshold = 0.7,
  diss_matrix = NULL,
  substitution_matrix = "BLOSUM62",
  id_force_splitting = NULL,
  tax_list = NULL,
  alpha = 0.5,
  return_front = NULL,
  SAopts = list(torun = TRUE),
  save_folder = NULL,
  ncpus = 1
)
}
\arguments{
\item{peptides.list}{list object returned by \code{\link[=extract_peptides]{extract_peptides()}}, containing
the data frame of windowed epitope data (\strong{df}) and the data frame of
individual peptides (\strong{peptides}).}

\item{proteins}{data frame of proteins.
containing all proteins listed in \code{peptides.list$df$Info_protein_id}.}

\item{split_level}{which sequences should be used to calculate similarity
for splitting the data.
Accepts "protein" (uses similarity of the full protein sequences,
\code{proteins$TSeq_sequence}, to determine which observations should stay
together in the splits) or "peptide" (uses similarity of the labelled
peptides, \code{peptides.list$peptides$Info_peptide}).
See \strong{Grouping strategy} for details.}

\item{target_props}{numeric vector of target proportions for each split
(i.e., a vector (p1, p2, ..., pK) such that 0 < pk < 1 for all k and
sum(pk) = 1).}

\item{split_names}{optional, vector of names to be given to each split.}

\item{similarity_threshold}{similarity threshold for grouping observations.
See \strong{Grouping strategy} for details.}

\item{diss_matrix}{dissimilarity matrix between all relevant elements
(all peptides if \code{split_level == "peptide"} or all proteins if
\code{split_level == "protein"}. If \code{NULL} then it is calculated internally.
See \strong{Grouping strategy} for details.}

\item{substitution_matrix}{character string indicating the substitution
matrix to be used to calculate the peptide / protein alignments.
(If \code{diss_matrix} is \code{NULL}).
Must be a matrix recognised by \code{\link[Biostrings:substitution_matrices]{Biostrings::substitution.matrices()}}
(e.g., "BLOSUM45", "PAM30", etc.)}

\item{id_force_splitting}{vector of lower-level taxonomy ids (integer or character)
that the splitting strategy should try to prioritise
distributing across splits (useful, e.g., if generating splits at a
higher taxonomic level for later re-use at a lower level). NOTE: these
need to be the IDs that appear under, e.g.,
\code{peptides.list$df$Info_organism_id} or
\code{proteins$TSeq_taxid}. No taxonomic search is performed within this
routine.}

\item{tax_list}{taxonomy list. Only used if
\code{id_force_splitting} is not \code{NULL}.}

\item{alpha}{weight parameter to regulate focus on maximising match to desired
split proportions (\code{target_props}) vs. on approximating the class
balance of the full data set. Must be a numeric value between 0 and 1.
See \strong{Optimisation Problem} for details.}

\item{return_front}{should different tradeoff solutions (based on distinct
values of alpha) be returned as well? Accepts either \code{NULL} (don't
calculate front) or a positive integer greater than 2
(number of equally spaced alpha values between 0 and 1 to evaluate).
If it's a positive integer, then the tradeoff dataset will be exported
as object \verb{$splits.attrs$tradeoffs} in the output list. Note that
only non-dominated tradeoffs are returned, so the number of tradeoff
points is likely to be smaller than the value of \code{return_front}.
Usually 11 or 21 points are enough to give a good rough idea of the
tradeoffs.}

\item{SAopts}{list of control parameters to be used by the simulated
annealing (SANN) algorithm. See \code{\link[stats:optim]{stats::optim()}} for details. Option
\code{torun} regulates whether to run SA or to return the solution found
by the constructive heuristic.}

\item{save_folder}{path to folder for saving the results. It will save the
results as file \emph{peptides_list.rds} (overwriting if necessary)}

\item{ncpus}{positive integer, number of cores to use.}
}
\value{
A list object containing:
\itemize{
\item \strong{df}: \code{peptides.list$df} updated to contain cluster number and
split allocation of each entry
\item \strong{peptides}: \code{peptides.list$peptides} updated to contain cluster
number and split allocation of each entry
\item \strong{proteins}: data frame containing data on all proteins listed in
\code{df$Info_protein_id}.
\item \strong{peptide.attrs}: list inherited from \code{peptides.list}, containing
relevant attributes used in the earlier call to \code{\link[=extract_peptides]{extract_peptides()}}.
\item \strong{splits.attrs}: list containing information about the splitting:
\itemize{
\item \emph{split_level}: same as input parameter \code{split_level}
\item \emph{similarity_threshold}: same as input parameter \code{similarity_threshold}
\item \emph{substitution_matrix}: same as input parameter \code{substitution_matrix}
\item \emph{split_props}: proportion of data allocated to each split
\item \emph{split_balance}: proportion of positive observations in each split
\item \emph{target_props}: same as input parameter \code{target_props}
\item \emph{target_balance}: proportion of positive observations in full data
\item \emph{alpha}: same as input parameter \code{alpha}
\item \emph{SW.scores}: local alignment scores between each sequence (Smith-Waterman)
\item \emph{diss.matrix}: dissimilarity matrix (see \strong{Grouping strategy} for details)
\item \emph{clusters}: \code{hclust} object with clustering structure.
\item \emph{cluster.alloc}: data frame summarising the split allocations.
\item \emph{tradeoffs}: data frame with tradeoffs between class balance and
nominal split size as a function of \code{alpha} (only if
\code{return_front} is not \code{NULL}).
}
}

If the splitting is impossible (e.g., if the number of clusters is smaller
than the desired number of splits) the function throws a warning and returns
a list with only \strong{SW.scores}, \strong{diss.matrix} and \strong{clusters}.
}
\description{
Split the windowed epitope data returned by \code{\link[=extract_peptides]{extract_peptides()}} into
non-overlapping subsets. Proteins / peptides with similarities higher than
a predefined threshold are always placed in the same split to prevent data
leakage in machine learning. This routine tries to simultaneously approximate
the user-defined proportions and maintain the overall class balance within
each split.
}
\section{\strong{Grouping strategy}}{

The first step of this routine is to group the observations at either the
proteins or the peptide level (depending on input parameter \code{split_level}).

If no \code{diss.matrix} is passed, local alignment scores for all pairs of
sequences are calculated using the
implementation of the Smith-Waterman algorithm available in function
\code{\link[Biostrings:pairwiseAlignment]{Biostrings::pairwiseAlignment()}}, with default parameters and the scoring
matrix defined in \code{substitution_matrix}. These scores are returned as
element \strong{SW.scores} of the output list. The dissimilarity matrix is
then calculated based on \strong{SW.scores}, as:

\code{diss[i,j] = 1 - SW.scores[i,j] / min(SW.scores[i,i], SW.scores[j,j])}

which gives a value between 0 (perfect similarity) and 1 (maximum
dissimilarity). \code{diss[i,j]} will be 0 if and only if the shorter sequence is
fully and perfectly contained in the longer one; and will be 1 if and only
if the Smith-Waterman alignment score is zero.

The dissimilarity matrix is used to calculate a hierarchical clustering of
the sequences, and input parameter \code{similarity_threshold} is then used to
define the resulting similarity clusters. Single-linkage is used, to
guarantee that any pair of sequences with similarity
greater than \code{similarity_threshold} will always be contained within the same
cluster.
The resulting clusters (returned as element \strong{clusters} of the output list)
represent the allocation units that are considered by the optimisation
to split the data.
}

\section{\strong{Optimisation Problem}}{

This routine attempts to simultaneously minimise two objectives: (i) the
difference between the actual proportion of data within each split and the
desired levels informed by \code{target_props}, and (ii) the difference between the
proportion of \emph{positive} observations within each split and the overall
proportion in the data. A simple linear aggregation strategy is used to
define the following optimisation problem. Let:
\itemize{
\item nC:  number of clusters.
\item K:   number of splits.
\item xi:  integer variable defining the split to which cluster i is allocated.
\item Ni+: number of \emph{positive} observations in cluster i.
\item Ni:  total number of observations in cluster i.
\item Gj*: desired proportion of data for split j.
\item P*:  proportion of \emph{positive} observations in the whole data.
}

We want to solve the problem:

\verb{minimize sum_j\{ alpha x (Gj - Gj*)^2 + (1-alpha) x (pj - P*)^2 \}}

With:
\itemize{
\item \verb{xi \\in \{1, ..., K\}}, for all \verb{i = 1, ..., nC}
\item \code{yij = ifelse(xi == j, 1, 0)}
\item \verb{Gj = sum_i\{ yij * Ni \} / sum_i\{ Ni \}}
\item \verb{pj = sum_i\{ yij * Ni+ \} / sum_i\{ yij * Ni \}}
}

Input parameter \code{alpha} regulates the relative importance attributed to
each of the two objectives. At the limits, \code{alpha = 0} ignores the desired
proportions and
focuses only on defining splits with class balances that are as close as
possible to \strong{P*}, whereas \code{alpha = 0} ignores the class balance and tries
to simply generate splits that are as faithful as possible to the desired
proportions. An approximation to the Pareto-optimal front can be obtained
by varying \code{alpha} between these two values.

The search space of this optimisation problem has a cardinality of
\code{K ^ nC}. If the cardinality is under \code{10^6} possible
allocations then this routine performs enumerative search and is guaranteed
to return the global optimum. For larger search spaces a
constructive heuristic followed by Simulated Annealing (see \code{\link[stats:optim]{stats::optim()}}
for details) is used. Input parameter \code{SAopts} can be used to pass control
parameters to the Simulated Annealing.
}

\author{
Felipe Campelo (\email{f.campelo@aston.ac.uk})
}
